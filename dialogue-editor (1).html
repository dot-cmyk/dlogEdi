<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>대화 에디터</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .scene { border: 1px solid #ccc; padding: 15px; margin: 10px 0; }
        .scene-header {
        margin-bottom: 15px;
    }
    .scene-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    .fold-btn {
        padding: 5px 10px;
        background: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;
    }
    .sceneDel-btn {
        padding: 5px 10px;
        background: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;
    }
    .scene-controls {
        display: flex;
        gap: 10px;
    }

        .dialogue { margin: 10px 0; padding: 10px; background: #f5f5f5; }
        button { margin: 0px; padding: 5px; }
        
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-btn:hover {
            color: black;
        }
        .config-section {
            margin-bottom: 20px;
        }
        .config-group {
            margin-bottom: 15px;
        }
        .config-row {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            align-items: center;
        }
        .config-row input {
            flex: 1;
        }
        .character-input {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            align-items: center;
        }
        .character-input input {
            flex: 1;
        }
        .character-input button {
            width: 30px;
            height: 30px;
            padding: 0;
        }
        
        .Dialoguedelete-btn {
        padding: 0px 0px;
        background: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;
    }




        .dialogue-header {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .dialogue-header select {
            width: 150px;
        }
        .dialogue-effect-select {
            margin-left: auto;
            width: 150px;
        }
        
        .dialogue-content {
            display: flex;
            gap: 20px;
        }
        .dialogue-main {
            flex: 1;
        }
        .dialogue-effects {
            width: 300px;
            border-left: 1px solid #ccc;
            padding-left: 20px;
        }
        
        textarea { 
            width: 100%; 
            min-height: 60px; 
            resize: vertical;
            margin: 5px 0; 
        }
        
        .effect-input { 
            margin: 5px 0; 
            padding: 5px;
            background: #e9e9e9;
            border-radius: 4px;
        }
        .effect-row { 
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin: 5px 0;
            position: relative;
            padding-right: 30px; /* 삭제 버튼을 위한 공간 */
        }
        .effect-row input { 
            width: 90%;
        }
        .effect-row select { 
            width: 90%;
        }
        .delete-btn { 
            position: absolute;
            right: 0;
            top: 0;
            width: 24px;
            height: 24px;
            padding: 0;
            
            background: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .effect-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: -3px;
        }


        .options-container {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .option-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        .option-item input, .option-item select {
            margin: 5px 0;
            width: 100%;
        }
        .option-functions {
            margin-left: 20px;
            padding: 5px;
            background: #f8f8f8;
        }

    </style>
</head>
<body>
    <h2>대화 에디터</h2>
    
    <input type="file" id="fileInput" accept=".json">
    <button onclick="saveToFile()">저장</button>
    <button onclick="addScene()">씬 추가</button>
    <button onclick="openModal()">변수 설정</button>
<!-- 변수 설정 모달 -->
<div id="configModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal()">&times;</span>
        <h2>변수 설정</h2>
        
        <div class="config-section">
            <div class="config-group">
                <h3>캐릭터 목록</h3>
                <div id="character-list"></div>
                <button onclick="addCharacter()">캐릭터 추가</button>
            </div>

            <div class="config-group">
                <h3>배경 목록</h3>
                <div id="background-list"></div>
                <button onclick="addConfigItem('background')">배경 추가</button>
            </div>

                <div class="config-group">
                    <h3>BGM 목록</h3>
                    <div id="bgm-list"></div>
                    <button onclick="addConfigItem('bgm')">BGM 추가</button>
                </div>

                <div class="config-group">
                    <h3>효과 목록</h3>
                    <div id="effect-list"></div>
                    <button onclick="addConfigItem('effect')">효과 추가</button>
                </div>

                <div class="config-group">
                    <h3>사운드 효과 목록</h3>
                    <div id="soundEffects-list"></div>
                    <button onclick="addConfigItem('soundEffects')">사운드 효과 추가</button>
                </div>

                <div class="config-group">
                    <h3>표정 목록</h3>
                    <div id="expressions-list"></div>
                    <button onclick="addConfigItem('expressions')">표정 추가</button>
                </div>
            </div>
        </div>
    </div>

    <div id="editor"></div>
    <script src="https://apis.google.com/js/api.js" onload="loadGoogleAPI()"></script>
    <script>
        // 씬의 접힘 상태를 저장할 객체
let sceneStates = {};
        let dialogueData = {
            character_name: [{key: "default", value: "기본캐릭터"} // 기본값 추가
            ],
            background: [],
            bgm: [],
            effect: [],
            soundEffects: [],
            expressions: ["default"],
            scenes: []
        };
        function addDialogueOption(sceneIndex, dialogueIndex) {
            const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
            if (!dialogue.options) {
                dialogue.options = [];
            }
            dialogue.options.push({
                text: "",
                next_scene: "end",
                functionToCall: []
            });
            renderEditor();
        }

        function removeDialogueOption(sceneIndex, dialogueIndex, optionIndex) {
            dialogueData.scenes[sceneIndex].dialogues[dialogueIndex].options.splice(optionIndex, 1);
            if (dialogueData.scenes[sceneIndex].dialogues[dialogueIndex].options.length === 0) {
                delete dialogueData.scenes[sceneIndex].dialogues[dialogueIndex].options;
            }
            renderEditor();
        }

        function addOptionFunction(sceneIndex, dialogueIndex, optionIndex) {
            const option = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex].options[optionIndex];
            if (!option.functionToCall) {
                option.functionToCall = [];
            }
            option.functionToCall.push({
                function: "",
                params: ""
            });
            renderEditor();
        }

        function removeOptionFunction(sceneIndex, dialogueIndex, optionIndex, functionIndex) {
            dialogueData.scenes[sceneIndex].dialogues[dialogueIndex].options[optionIndex].functionToCall.splice(functionIndex, 1);
            renderEditor();
        }
 // 모달 관련 함수들
 function addCharacter() {
            dialogueData.character_name.push({
                key: "",
                value: ""
            });
            renderConfigLists();
        }
        function removeCharacter(index) {
            dialogueData.character_name.splice(index, 1);
            renderConfigLists();
        }

        function updateCharacter(index, field, value) {
            dialogueData.character_name[index][field] = value;
        }

 function openModal() {
            document.getElementById('configModal').style.display = 'block';
            renderConfigLists();
        }

        function closeModal() {
            document.getElementById('configModal').style.display = 'none';
        }

        // 설정 관련 함수들
        function addConfigItem(listName) {
            dialogueData[listName].push('');
            renderConfigLists();
        }

        function removeConfigItem(listName, index) {
            dialogueData[listName].splice(index, 1);
            renderConfigLists();
        }

        function updateConfigItem(listName, index, value) {
            dialogueData[listName][index] = value;
        }

        function renderConfigLists() {
            // 캐릭터 목록 렌더링
            const characterContainer = document.getElementById('character-list');
            characterContainer.innerHTML = '';
            
            dialogueData.character_name.forEach((char, index) => {
                const row = document.createElement('div');
                row.className = 'character-input';
                row.innerHTML = `
                    <input 
                        value="${char.key}" 
                        placeholder="캐릭터 key"
                        onchange="updateCharacter(${index}, 'key', this.value)"
                    >
                    <input 
                        value="${char.value}" 
                        placeholder="캐릭터 이름"
                        onchange="updateCharacter(${index}, 'value', this.value)"
                    >
                    <button onclick="removeCharacter(${index})">X</button>
                `;
                characterContainer.appendChild(row);
            });

            const configLists = ['background', 'bgm', 'effect', 'soundEffects', 'expressions'];
            
            configLists.forEach(listName => {
                const container = document.getElementById(`${listName}-list`);
                container.innerHTML = '';
                
                dialogueData[listName].forEach((item, index) => {
                    const row = document.createElement('div');
                    row.className = 'config-row';
                    row.innerHTML = `
                        <input 
                            value="${item}" 
                            placeholder="${listName} 입력"
                            onchange="updateConfigItem('${listName}', ${index}, this.value)"
                        >
                        <button onclick="removeConfigItem('${listName}', ${index})">삭제</button>
                    `;
                    container.appendChild(row);
                });
            });
        }
        function handleFileLoad(e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    dialogueData = JSON.parse(event.target.result);
                    renderConfigLists();  // 설정 목록 업데이트
                    renderEditor();       // 에디터 업데이트
                   
                } catch (error) {
                    console.error(error);
                    alert('파일 읽기 오류!');
                }
            };
            reader.readAsText(file);
        }

        // 파일 관련 함수들
        document.getElementById('fileInput').addEventListener('change', handleFileLoad);


        function addScene() {
            const newSceneId = `scene_${dialogueData.scenes.length + 1}`;
            dialogueData.scenes.push({
                scene_id: newSceneId,
                background: dialogueData.background[0] || "",
                bgm: dialogueData.bgm[0] || "",
                dialogues: []
            });
            renderEditor();
        }

        function addDialogue(sceneIndex) {
            dialogueData.scenes[sceneIndex].dialogues.push({
        character: dialogueData.character_name[0]?.key || '',
        text: [''],  // 배열로 초기화
        expression: dialogueData.expressions[0] || ''
    });
            renderEditor();
        }

        function addFunction(sceneIndex, dialogueIndex) {
            const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
            if (!dialogue.functionToCall) {
                dialogue.functionToCall = [];
            }
            dialogue.functionToCall.push({
                function: "",
                parmas: ""
            });
            renderEditor();
        }

        function removeFunction(sceneIndex, dialogueIndex, functionIndex) {
            dialogueData.scenes[sceneIndex].dialogues[dialogueIndex].functionToCall.splice(functionIndex, 1);
            renderEditor();
        }

        function handleEffectSelect(sceneIndex, dialogueIndex, type) {
            const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
            if (type === 'function') {
                addFunction(sceneIndex, dialogueIndex);
            } else if (type === 'sound') {
                dialogue.sound_effect = soundEffects[0];
            } else if (type === 'scene') {
                dialogue.effect = sceneEffects[0];
            } else if (type === 'next_scene') {
                dialogue.next_scene = dialogueData.scenes[0]?.scene_id || 'end';
            }
            renderEditor();
        }

        function removeEffect(sceneIndex, dialogueIndex, type) {
            const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
            if (type === 'sound') {
                delete dialogue.sound_effect;
            } else if (type === 'scene') {
                delete dialogue.effect;
            } else if (type === 'next_scene') {
                delete dialogue.next_scene;
            }
            renderEditor();
        }
        function removeDialogue(sceneIndex, dialogueIndex) {
    dialogueData.scenes[sceneIndex].dialogues.splice(dialogueIndex, 1);
    renderEditor();
}
function confirmRemoveScene(sceneIndex) {
    const sceneId = dialogueData.scenes[sceneIndex].scene_id;
    if (confirm(`정말로 씬 '${sceneId}'를 삭제하시겠습니까?`)) {
        removeScene(sceneIndex);
    }
}

function removeScene(sceneIndex) {
    dialogueData.scenes.splice(sceneIndex, 1);
    renderEditor();
}
        function renderEditor() {
    const editor = document.getElementById('editor');
    editor.innerHTML = '';

    dialogueData.scenes.forEach((scene, sceneIndex) => {
        const sceneDiv = document.createElement('div');
        sceneDiv.className = 'scene';
        
        // 씬 헤더 (ID, 배경, BGM, 접기 버튼)
        const sceneHeader = document.createElement('div');
        sceneHeader.className = 'scene-header';
        sceneHeader.innerHTML = `
            <div class="scene-title">
                <h3>씬 ${sceneIndex + 1}</h3>
                <button class="sceneDel-btn" onclick="confirmRemoveScene(${sceneIndex})">씬 삭제</button>
                <button class="fold-btn" onclick="toggleScene(${sceneIndex})">접기</button>
            </div>
            <div class="scene-controls">
                <input 
                    value="${scene.scene_id}" 
                    placeholder="씬 ID" 
                    onchange="dialogueData.scenes[${sceneIndex}].scene_id = this.value"
                >
                <select onchange="dialogueData.scenes[${sceneIndex}].background = this.value">
                    <option value="">배경 선택</option>
                    ${dialogueData.background.map(bg => 
                        `<option value="${bg}" ${scene.background === bg ? 'selected' : ''}>
                            ${bg}
                        </option>`
                    ).join('')}
                </select>
                <select onchange="dialogueData.scenes[${sceneIndex}].bgm = this.value">
                    <option value="">BGM 선택</option>
                    ${dialogueData.bgm.map(b => 
                        `<option value="${b}" ${scene.bgm === b ? 'selected' : ''}>
                            ${b}
                        </option>`
                    ).join('')}
                </select>
            </div>
        `;
        sceneDiv.appendChild(sceneHeader);

        // 씬 컨텐츠 (대사들)
        const sceneContent = document.createElement('div');
        sceneContent.className = 'scene-content';
        sceneContent.id = `scene-content-${sceneIndex}`;
         // 저장된 상태가 있으면 적용
    if (sceneStates[sceneIndex]) {
        sceneContent.style.display = 'none';
        sceneHeader.querySelector('.fold-btn').textContent = '펼치기';
    } else {
        sceneContent.style.display = 'block';
        sceneHeader.querySelector('.fold-btn').textContent = '접기';
    }

        if (scene.dialogues) {
            scene.dialogues.forEach((dialogue, dialogueIndex) => {
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'dialogue';
                
                // 헤더 부분 (캐릭터, 표정, 효과추가 선택)
                dialogueDiv.innerHTML = `
                    <div class="dialogue-header">
                        <select onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].character = this.value">
                            ${dialogueData.character_name.map(char => 
                                `<option value="${char.key}" ${dialogue.character === char.key ? 'selected' : ''}>
                                    ${char.value}
                                </option>`
                            ).join('')}
                        </select>
                        
                        <select onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].expression = this.value">
                            <option value="">표정 선택</option>
                            ${dialogueData.expressions.map(exp => 
                                `<option value="${exp}" ${dialogue.expression === exp ? 'selected' : ''}>
                                    ${exp}
                                </option>`
                            ).join('')}
                        </select>
                        <button onclick="addVariantText(${sceneIndex}, ${dialogueIndex})">대사 추가</button>
                        <button class="Dialoguedelete-btn" onclick="removeDialogue(${sceneIndex}, ${dialogueIndex})">대사 삭제</button>

                        <select class="dialogue-effect-select" onchange="handleEffectSelect(${sceneIndex}, ${dialogueIndex}, this.value)">
                            <option value="">효과 추가...</option>
                            <option value="function">함수 추가</option>
                            <option value="sound">사운드 추가</option>
                            <option value="scene">씬 효과 추가</option>
                            <option value="next_scene">다음 씬 설정</option>
                            <option value="options">선택지 추가</option>
                        </select>
                    </div>
                     
                `;

                // 컨텐츠 부분 (대사와 효과들)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'dialogue-content';

                // 대사 영역
                const mainDiv = document.createElement('div');
                mainDiv.className = 'dialogue-main';
                mainDiv.innerHTML = `
                    <div class="text-variants">
        <div class="text-variant">
            <textarea 
                onchange="updateDialogueText(${sceneIndex}, ${dialogueIndex}, 0, this.value)"
                placeholder="기본 대사 입력"
            >${Array.isArray(dialogue.text) ? dialogue.text[0] || '' : dialogue.text || ''}</textarea>
        </div>
        ${Array.isArray(dialogue.text) ? 
            dialogue.text.slice(1).map((text, variantIndex) => `
                <div class="text-variant">
                    <textarea 
                        onchange="updateDialogueText(${sceneIndex}, ${dialogueIndex}, ${variantIndex + 1}, this.value)"
                        placeholder="추가 대사 입력"
                    >${text || ''}</textarea>
                    <button class="delete-btn" onclick="removeVariantText(${sceneIndex}, ${dialogueIndex}, ${variantIndex + 1})">X</button>
                </div>
            `).join('') 
            : ''}
    </div>
                `;
                contentDiv.appendChild(mainDiv);

                // 효과들 영역
                const effectsDiv = document.createElement('div');
                effectsDiv.className = 'dialogue-effects';

                // 함수 효과들
                if (dialogue.functionToCall) {
                    dialogue.functionToCall.forEach((func, funcIndex) => {
                        const functionDiv = document.createElement('div');
                        functionDiv.className = 'effect-input';
                        functionDiv.innerHTML = `
                            <div class="effect-row">
                                <span class="effect-label">함수 이름</span>
                                <input 
                                    value="${func.function || ''}" 
                                    placeholder="함수 이름"
                                    onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].functionToCall[${funcIndex}].function = this.value"
                                >
                                <span class="effect-label">매개변수</span>
                                <input 
                                    value="${func.params || ''}" 
                                    placeholder="매개변수"
                                    onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].functionToCall[${funcIndex}].params = this.value"
                                >
                                <button class="delete-btn" onclick="removeFunction(${sceneIndex}, ${dialogueIndex}, ${funcIndex})">X</button>
                            </div>
                        `;
                        effectsDiv.appendChild(functionDiv);
                    });
                }

                // 사운드 효과
                if (dialogue.sound_effect) {
                    const soundDiv = document.createElement('div');
                    soundDiv.className = 'effect-input';
                    soundDiv.innerHTML = `
                        <div class="effect-row">
                            <select onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].sound_effect = this.value">
                                ${dialogueData.soundEffects.map(se => 
                                    `<option value="${se}" ${dialogue.sound_effect === se ? 'selected' : ''}>
                                        ${se}
                                    </option>`
                                ).join('')}
                            </select>
                            <button class="delete-btn" onclick="removeEffect(${sceneIndex}, ${dialogueIndex}, 'sound')">X</button>
                        </div>
                    `;
                    effectsDiv.appendChild(soundDiv);
                }

                // 씬 효과
                if (dialogue.effect) {
                    const effectDiv = document.createElement('div');
                    effectDiv.className = 'effect-input';
                    effectDiv.innerHTML = `
                        <div class="effect-row">
                            <select onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].effect = this.value">
                                ${dialogueData.effect.map(ef => 
                                    `<option value="${ef}" ${dialogue.effect === ef ? 'selected' : ''}>
                                        ${ef}
                                    </option>`
                                ).join('')}
                            </select>
                            <button class="delete-btn" onclick="removeEffect(${sceneIndex}, ${dialogueIndex}, 'scene')">X</button>
                        </div>
                    `;
                    effectsDiv.appendChild(effectDiv);
                }

                // 다음 씬
                if (dialogue.next_scene !== undefined) {
                    const nextSceneDiv = document.createElement('div');
                    nextSceneDiv.className = 'effect-input';
                    nextSceneDiv.innerHTML = `
                        <div class="effect-row">
                            <select onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].next_scene = this.value">
                                ${dialogueData.scenes.map(s => 
                                    `<option value="${s.scene_id}" ${dialogue.next_scene === s.scene_id ? 'selected' : ''}>
                                        ${s.scene_id}
                                    </option>`
                                ).join('')}
                                <option value="end" ${dialogue.next_scene === 'end' ? 'selected' : ''}>end</option>
                            </select>
                            <button class="delete-btn" onclick="removeEffect(${sceneIndex}, ${dialogueIndex}, 'next_scene')">X</button>
                        </div>
                    `;
                    effectsDiv.appendChild(nextSceneDiv);
                }

                // 선택지
                if (dialogue.options) {
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'options-container';
                    optionsDiv.innerHTML = '<h4>선택지</h4>';

                    dialogue.options.forEach((option, optionIndex) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option-item';
                        optionDiv.innerHTML = `
                            <input 
                                value="${option.text || ''}" 
                                placeholder="선택지 텍스트"
                                onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].options[${optionIndex}].text = this.value"
                            >
                            <select onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].options[${optionIndex}].next_scene = this.value">
                                <option value="">다음 씬 선택</option>
                                ${dialogueData.scenes.map(s => 
                                    `<option value="${s.scene_id}" ${option.next_scene === s.scene_id ? 'selected' : ''}>
                                        ${s.scene_id}
                                    </option>`
                                ).join('')}
                                <option value="end" ${option.next_scene === 'end' ? 'selected' : ''}>end</option>
                            </select>
                            <button onclick="addOptionFunction(${sceneIndex}, ${dialogueIndex}, ${optionIndex})">선택지 함수 추가</button>
                            <button onclick="removeDialogueOption(${sceneIndex}, ${dialogueIndex}, ${optionIndex})">선택지 삭제</button>
                        `;

                        // 선택지의 함수들
                        if (option.functionToCall && option.functionToCall.length > 0) {
                            const optionFunctionsDiv = document.createElement('div');
                            optionFunctionsDiv.className = 'option-functions';
                            
                            option.functionToCall.forEach((func, funcIndex) => {
                                const functionDiv = document.createElement('div');
                                functionDiv.className = 'effect-row';
                                functionDiv.innerHTML = `
                                    <span class="effect-label">함수 이름</span>
                                    <input 
                                        value="${func.function || ''}" 
                                        placeholder="함수 이름"
                                        onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].options[${optionIndex}].functionToCall[${funcIndex}].function = this.value"
                                    >
                                    <span class="effect-label">매개변수</span>
                                    <input 
                                        value="${func.params || ''}" 
                                        placeholder="매개변수"
                                        onchange="dialogueData.scenes[${sceneIndex}].dialogues[${dialogueIndex}].options[${optionIndex}].functionToCall[${funcIndex}].params = this.value"
                                    >
                                    <button class="delete-btn" onclick="removeOptionFunction(${sceneIndex}, ${dialogueIndex}, ${optionIndex}, ${funcIndex})">X</button>
                                `;
                                optionFunctionsDiv.appendChild(functionDiv);
                            });
                            optionDiv.appendChild(optionFunctionsDiv);
                        }

                        optionsDiv.appendChild(optionDiv);
                    });

                    effectsDiv.appendChild(optionsDiv);
                }

                contentDiv.appendChild(effectsDiv);
                dialogueDiv.appendChild(contentDiv);
                sceneContent.appendChild(dialogueDiv);
            });
        }

        // 대사 추가 버튼을 대사 목록 맨 끝에 추가
        const addDialogueButton = document.createElement('div');
        addDialogueButton.className = 'add-dialogue-btn-container';
        addDialogueButton.innerHTML = `
            <button onclick="addDialogue(${sceneIndex})">대사 추가</button>
        `;
        sceneContent.appendChild(addDialogueButton);

        sceneDiv.appendChild(sceneContent);
        editor.appendChild(sceneDiv);
    });

    // 씬 추가 버튼을 에디터 맨 끝에 추가
    const addSceneButton = document.createElement('div');
    addSceneButton.className = 'add-scene-btn-container';
    addSceneButton.innerHTML = `
        <button onclick="addScene()">씬 추가</button>
        <button style="float: right;" onclick="copyToClipboard()">클립보드 복사</button>
        <button style="float: right;"  onclick="saveToFile()">저장</button>
        <button style="float: right;" id="driveLoad" style="display: none;">드라이브에서 불러오기</button>
        <button style="float: right;" id="driveSave" style="display: none;">드라이브에 저장</button>  
    `;
    editor.appendChild(addSceneButton);
}
// Google API 라이브러리 로드
function loadGoogleAPI() {
    gapi.load('client:auth2', initClient);
}

// API 클라이언트 초기화
function initClient() {
    gapi.client.init({
        apiKey: 'YOUR_API_KEY',
        clientId: 'YOUR_CLIENT_ID',
        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
        scope: 'https://www.googleapis.com/auth/drive.file'
    }).then(function() {
        // 인증 상태 리스너
        gapi.auth2.getAuthInstance().isSignedIn.listen(updateSignInStatus);
        // 초기 인증 상태 확인
        updateSignInStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
        // 로그인 버튼 이벤트 연결
        document.getElementById('googleSignIn').onclick = handleAuthClick;
    });
}

// 인증 상태에 따른 UI 업데이트
function updateSignInStatus(isSignedIn) {
    if (isSignedIn) {
        document.getElementById('googleSignIn').style.display = 'none';
        document.getElementById('driveLoad').style.display = 'inline';
        document.getElementById('driveSave').style.display = 'inline';
    } else {
        document.getElementById('googleSignIn').style.display = 'inline';
        document.getElementById('driveLoad').style.display = 'none';
        document.getElementById('driveSave').style.display = 'none';
    }
}

// 로그인 처리
function handleAuthClick() {
    gapi.auth2.getAuthInstance().signIn();
}
// 드라이브에서 파일 불러오기
function loadFromDrive() {
    // 파일 선택 다이얼로그 표시
    gapi.client.drive.files.list({
        q: "mimeType='application/json'",
        spaces: 'drive',
        fields: 'files(id, name)'
    }).then(function(response) {
        const files = response.result.files;
        // 파일 목록을 보여주고 선택하게 하는 UI 표시
        showFileSelector(files);
    });
}

// 드라이브에 저장하기
function saveToDrive() {
    const fileContent = JSON.stringify(dialogueData, null, 2);
    const file = new Blob([fileContent], {type: 'application/json'});
    const metadata = {
        'name': 'dialogue_data.json', // 저장할 파일 이름
        'mimeType': 'application/json'
    };

    const form = new FormData();
    form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
    form.append('file', file);

    // 파일 업로드
    fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
        method: 'POST',
        headers: new Headers({
            'Authorization': 'Bearer ' + gapi.auth.getToken().access_token
        }),
        body: form
    }).then(response => {
        alert('파일이 드라이브에 저장되었습니다.');
    }).catch(error => {
        console.error('Error:', error);
        alert('저장 중 오류가 발생했습니다.');
    });
}

// 클립보드 복사 함수 추가
function copyToClipboard() {
    try {
        const dataStr = JSON.stringify(dialogueData, null, 4);  // 4칸 들여쓰기로 포맷팅
        navigator.clipboard.writeText(dataStr).then(() => {
            alert('클립보드에 복사되었습니다.');
        }).catch(err => {
            console.error('클립보드 복사 실패:', err);
            fallbackCopyToClipboard(dataStr);
        });
    } catch (error) {
        console.error('JSON 변환 실패:', error);
        alert('JSON 변환 중 오류가 발생했습니다.');
    }
}
// 폴백 복사 함수 (clipboard API가 지원되지 않는 경우를 위한 대비책)
function fallbackCopyToClipboard(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    try {
        document.execCommand('copy');
        alert('클립보드에 복사되었습니다.');
    } catch (err) {
        console.error('폴백 복사 실패:', err);
        alert('클립보드 복사에 실패했습니다.');
    }
    document.body.removeChild(textArea);
}
// 씬 접기/펼치기 함수
// 씬 접기/펼치기 함수 수정
function toggleScene(sceneIndex) {
    const sceneContent = document.getElementById(`scene-content-${sceneIndex}`);
    const button = sceneContent.parentElement.querySelector('.fold-btn');
    
    // 현재 상태를 반전
    sceneStates[sceneIndex] = !sceneStates[sceneIndex];
    
    // 상태에 따라 표시/숨김 처리
    if (sceneStates[sceneIndex]) {
        sceneContent.style.display = 'none';
        button.textContent = '펼치기';
    } else {
        sceneContent.style.display = 'block';
        button.textContent = '접기';
    }
}
// 새로운 함수들 추가
function updateDialogueText(sceneIndex, dialogueIndex, variantIndex, value) {
    const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
    if (!Array.isArray(dialogue.text)) {
        dialogue.text = [dialogue.text || ''];
    }
    dialogue.text[variantIndex] = value;
}
function addVariantText(sceneIndex, dialogueIndex) {
    const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
    if (!Array.isArray(dialogue.text)) {
        dialogue.text = [dialogue.text || ''];
    }
    dialogue.text.push('');
    renderEditor();
}

function removeVariantText(sceneIndex, dialogueIndex, variantIndex) {
    const dialogue = dialogueData.scenes[sceneIndex].dialogues[dialogueIndex];
    dialogue.text.splice(variantIndex, 1);
    renderEditor();
}
function handleEffectSelect(sceneIndex, dialogueIndex, type) {
            if (type === 'options') {
                addDialogueOption(sceneIndex, dialogueIndex);
            } else {
                // ... 이전 효과 처리 코드 유지 ...
            }
            renderEditor();
        }
 function saveToFile() {
            const dataStr = JSON.stringify(dialogueData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dialogue_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        renderEditor();
          // 모달 외부 클릭 시 닫기
          window.onclick = function(event) {
            const modal = document.getElementById('configModal');
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }
    </script>
</body>
</html>
